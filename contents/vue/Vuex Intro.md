# 🔰What is Vuex? 

- 상태(state)를 전역 저장소로 관리할 수 있도록 지원하는 라이브러리
  - 상태가 예측 가능한 방식으로만 변경될 수 있도록 보장하는 규칠 설정
  - 애플리케이션의 모든 컴포넌트에 대한 <span style="color: indianred"> 중앙 집중식 저장소</span> 역할

- Vue의 공식 devtools와 통합되어 기타 고급 기능을 제공
- 상태 관리 패턴 + 라이브러리
- [공식문처 참고](https://vuex.vuejs.org/)

<br>

## 🌈 상태 관리 패턴

- 컴포넌트의 공유된 상태를 추출하고 이를 전역에서 관리 하도록 함
- 컴포넌트는 커다란 view가 되며 모든 컴포넌트는 트리에 상관없이 상태에 엑세스 하거나 동작을 트리거 할 수 있음
- 상태 관리 및 특징 규칙 정요과 관련된 개념을 정의하고 분리함으로써 코드의 구조와 유지 관리 기능 향상
- [참고] 트리거 : 특정한 동작에 반응해 자동으로 필요한 동작을 실행하는 것

<br>

## 🌈 Vuex를 활용한 state(상태) 관리

![image-20220511232718269](Vuex%20Intro.assets/image-20220511232718269.png)

1. 상태의 변화에 따른 여러 흐름을 모두 관리해야 하는 불편함을 해소 할 필요가 있음
   - 상태는 데이터를 주고 받는 컴포넌트 사이의 관계도 충분히 고려해야 하기 때문에 상태 흐름 관리가 매우 중요해짐
2. 결국 이러한 상태를 '올바르게 관리하는 저장소' 의 필요성을 느끼게 됨
   - 상태를 한 곳(store)에 모두 모아 놓고 관리하자
   - 상태의 변화는 모든 컴포넌트에서 공유
   - 상태의 변화는 오로지 Vuex가 관리하여 해당 상태를 공유하고 있는 모든 컴포넌트는 변화에 '반응'
3. A 컴포넌트와 같은 상태를 공유하는 다른 컴포넌트는 신경쓰지 않고, 오로지 상태의 변화를 Vuex에 알림

<br>

## 💡 Vuex 핵심 개념

![image-20220511233127812](Vuex%20Intro.assets/image-20220511233127812.png)

<hr>

<br>

## 🪴1. State

- "중앙에서 관리하는 모든 상태 정보(data)"
- 여러 컴포넌트 내부에 있는 특정 state를 중앙에서 관리하게 됨
  - 이전의 방식은 state를 찾기 위해 각 컴포넌트를 직접 확인해야 했음
  - Vuex를 활용하는 방식은 Vuex Store에서 각 컴포넌트에서 사용하는 state를 한 눈에 파악 가능
- State가 변화하면 해당 state를 공유하는 여러 컴포넌트의 DOM은 (알아서) 렌더링
- 각 컴포넌트는 이제 Vuex Store에서 state 정보를 가져와 사용

<br>

## 🪴2. Mutations

- "실제로 state를 변경하는 유일한 방법"
- mutation의 handler(핸들러 함수)는 반드시 동기적이어야 함
  - 비동기적 로직(ex. 콜백함수)은 state가 변화하는 시점이 의도한 것과 달라질 수 있으며, 콜백이 실제로 호출 될 시기를 알 수 있는 방법이 없음 (추적 할 수 없음)
- **<u>첫번째 인자로 항상 state를 받음</u>**
- Actions에서 `commit()` 메서드에 의해 호출됨

<br>

## 🪴3. Actions

- Mutations와 유사하지만 다음과 같은 차이점이 있음

  1. state를 변경하는 대신 mutations를 `commit()` 메서드로 호출해서 실행

  2. mutations와 달리 비동기 작업이 포함될 수 있음

     (Backend API와 통신하여 Data Fetching 등의 작업 수행)

- <span style="color: indianred">context</span> 객체 인자를 받음

  - context 객체를 통해 `store/index.js` 파일 내에 있는 모든 요소의 속성 접근 & 메서드 호출이 가능
  - 단, (가능하지만) state를 직접 변경하지 않음, state는 오로지 Mutations를 통해서만 조작 해야함
    - 명확한 역할 분담을 통해 서비스 규모가 커져도 state를 올바르게 관리하기 위함

- 컴포넌트에서 `dispatch()` 메서드에 의해 호출 됨

<br>



## 🪴4. Getters

- state를 변경하지 않고 활용하여 계산을 수행 (computed 속성과 유사)
  - computed를 사용하는 것처럼 getters는 저장소의 상태(state)를 기준으로 계산
  - 예를 들어, state에 `todoList`라는 해야 할 일의 목록의 경우 완료된 `todo` 목록만을 필터링해서 출력해야 하는 경우가 있음
- computed 속성과 마찬가지로 getters의 결과는 state 종속성에 따라 캐시(cached)되고, 종속성이 변경된 경우에만 다시 재계산 됨
- getters 자체가 state를 변경하지는 않음
  - state를 특정한 조건에 따라 구분(계산)만 함
  - 즉, 계산된 값을 가져옴