# [운영체제] - 페이징을 통한 가상 메모리 관리

> 페이징은 운영체제 메모리 관리 기법에 있어 가장 중요한 개념! 왜 생겼고, 어떤 원리로 작동하는지 알아보자!

<hr>

<br>

![image-20230102185218006](%5B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%5D%20-%20%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%84%20%ED%86%B5%ED%95%9C%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC.assets/image-20230102185218006.png)

프로세스를 메모리에 연속적으로 할당하는 방식은 `외부 단편화`, 물리 메모리보다 큰 프로세스를 실행할 수 없다는 문제점을 가지고 있다. 8GB 메모리가 설치된 컴퓨터로는 8GB 이상의 프로그램 실행 불가!

가상 메모리 : 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술로 이를 가능하게 하는 방법은 `페이징`, `세그멘테이션`이 있다.

<BR>

### - 페이징

> 프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법

![image-20230102190758887](%5B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%5D%20-%20%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%84%20%ED%86%B5%ED%95%9C%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC.assets/image-20230102190758887.png)

위 그림 처럼 메모리 공간과 프로세스를 1GB 단위의 일정한 크기로 자르고, 잘린 메모리 조각들에 프로세스 조각들을 불연속적으로 적재할 수 있다면, 외부 단편화는 발생하지 않는다. 

이것을 `페이징` 이라고 한다. 프로세스의 논리 주소 공간을 페이지 라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법

<BR>

### - 페이지 테이블

> 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표

그런데, 프로세스가 메모리에 불연속적으로 배치되어 있다면, CPU 입장에서는 각 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 모두 알고 있기 어렵기 때문에 순차적으로 실행할 수 없다.

이를 해결하기 위해 페이징 시스템은 프로세스가 (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도 (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 `페이지 테이블`을 이용한다.

![image-20230102191835784](%5B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%5D%20-%20%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%84%20%ED%86%B5%ED%95%9C%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC.assets/image-20230102191835784.png)

위와 같이 물리 주소상에서는 프로세스들이 분산되어 저장되어 있어도, CPU 입장에서는 논리주소를 바라보기 때문에 연속적으로 보일 수 있고 순차적으로 실행할 수 있다. 

<BR>

### - 페이지 테이블 엔트리

> 페이지 테이블의 각각의 행들을 페이지 테이블 엔트리 라고 한다.

페이지 테이블 엔트리에는 페이지 번호, 엔트리 번호 이외에도 중요한 정보들이 있다.

![image-20230102193415595](%5B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%5D%20-%20%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%84%20%ED%86%B5%ED%95%9C%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC.assets/image-20230102193415595.png)

- 유효 비트 : 현재 해당 페이지에 접근이 가능한지 여부를 알려준다. 현재 페이지가 메모리에 적재되어 있다면 1, 페이지가 메모리에 적재되어 있지 않고 보조기억장치에 있다면 0
  - 페이지 폴트 : CPU가 유효 비트가 0인 페이지에 접근하려 할 때 발생하는 예외!
    1. CPU는 기존의 작업 내역을 백업한다.
    2. 페이지 폴트 처리 루틴을 실행한다.
    3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경한다.
    4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근 가능하다.
- 보호 비트 : 페이지 보호 기능을 위해 존재하는 비트
- 참조 비트 : CPU가 해당 페이지에 접근한 적이 있는지 여부를 나타냄
- 수정 비트 : 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려줌. `더티비트`라고도 한다. 