# 🌱 트리

#### 1. 원소들 간에 1: n 관계를 가지는 비선형 자료구조

#### 2. 원소들 간에 계층 관계를 가지는 계층형 자료구조

#### 3. 상위 원소에 서 하위 원소로 내려가면서 확장되는 트리(나무) 모양의 구조

![image-20220316210107217](Tree%201.assets/image-20220316210107217.png)

- `노드` - 트리의 원소
  - 트리 T의 노드 - `A`, `B`, `C`, `D`, `E`, `F`, `G`, `H` , `I`, `J`, `K`
- `간선(edge)` - 노드를 연결하는 선, 부모 노드와 자식 노드를 연결
- `루트 노드` - 트리의 시작 노드 (A)

- `형제 노드` - 같은 부모 노드의 자식 노드들
  - `B`, `C`, `D`는 `A`를 부모로 하는 형제 노드
- `조상 노드` - 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
  - `K`의 조상 노드 : `F`, `B`, `A`
- `서브 트리` - 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
- `자손 노드` - 서브 트리에 있는 하위 레벨의 노드들
  - `B`의 자손 노드 - `E`, `F`, `K`
- `차수`
  - 노드의 차수 : 노드에 연결된 자식 노드의 수.
    - `B`의 차수 = 2, `C`의 차수 = 1
  - 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값
    - 트리 T의 차수 = 3
  - 단말 노드(리프 노드) : 차수가 0인 노드, 자식 노드가 없는 노드
- `높이` 
  - 노드의 높이 : 루트에서 노드에 이르는 간선의 수, 노드의 레벨
    - `B`의 높이 = 1, `F`의 높이 = 2, `A`의 높이 = 0
  - 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값, 최대 레벨
    - 트리 T의 높이 = 3



## 이진 트리

##### 1. 모든 노드들이 2개의 서브 트리를 갖는 특별한 형태의 트리

##### 2. 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리

- 왼쪽 자식 노드
- 오른쪽 자식 노드

##### 3. 이진 트리의 예

![image-20220316211830906](Tree%201.assets/image-20220316211830906.png)

### 특성

- 레벨 `i`에서의 노드의 최대 개수는 2<sup>i</sup>개
- 높이가 `h`인 이진 트리가 가질 수 있는 노드의 최소 개수는 `(h+1)`개가 되며, 최대 개수는 (2<sup>h+1</sup> -1) 개가 된다.

### 종류

#### `포화 이진 트리`

- 모든 레벨에 노드가 포화상태로 차 있는 이진 트리
- `모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리`
- 높이가 `h`일 때, 최대의 노드 개수인 (2<sup>h+1</sup> -1)의 노드를 가진 이진 트리
  - 높이가 3일 때 2<sup>3+1</sup>-1  = `15`개의 노드
- 루트를 1번으로 하여  (2<sup>h+1</sup> -1)까지 정해진 위치에 대한 노드 번호를 가짐

![image-20220316212314814](Tree%201.assets/image-20220316212314814.png)

#### `완전 이진 트리`

- 높이가 `h`이고 노드 수가 `n` 개일 때 (단, h+1 <= n <  (2<sup>h+1</sup> -1)), 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리
- `즉, 마지막 레벨은 꽉 차 있지 않아도 되지만, 노드가 왼쪽에서 오른쪽으로 채워 져야 한다.`
- 노드가 `10`개인 완전 이진 트리

![image-20220316212822711](Tree%201.assets/image-20220316212822711.png)

#### `편향 이진 트리`

- 높이 `h`에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리
- 노드 수 = `h` + 1

![image-20220316213246991](Tree%201.assets/image-20220316213246991.png)



## 이진트리 - 순회

> 순회 - 트리의 각 노드를 중복되지 않게 전부 방문하는 것을 말하는데, 트리는 비 선형 구조이기 때문에 선형 구조에서와 같이 선후 연결 관계를 알 수 없다.

#### 전위 순회-  `V(부모) -> L(왼쪽 서브트리) -> R(오른쪽 서브트리)`

```python
# 전위 순회
def pre_order(v):
    if v:   # 0번 정점이 없으므로... 0번은 자식이 없는 경우를 표시
        print(v, end = ' ')   # visit(v), vis
        pre_order(ch1[v])   # 왼쪽 자식으로 이동
        pre_order(ch2[v])   # 오른쪽 자식으로 이동
print(pre_order(1))
```

#### 중위 순회 -  `L(왼쪽 서브트리) -> V(부모) -> R(오른쪽 서브트리)`

```python
# 중위 순회
def in_order(v):
    if v:
        in_order(ch1[v])
        print(v, end = ' ')
        in_order(ch2[v])
in_order(1)
```

#### 후위 순회 -  `L(왼쪽 서브트리) -> R(오른쪽 서브트리) -> V(부모)`

```python
# 후위 순회
def post_order(v):
    if v:
        post_order(ch1[v])
        post_order(ch2[v])
        print(v, end = ' ')
post_order(1)
```



## 배열로 이진 트리 표현하기

> 루트의 번호를 `1`로 하고, 레벨 `n`에 있는 노드에 대하여 왼쪽부터 오른쪽으로 2<sup>n</sup>부터 2<sup>n+1</sup>-1까지 번호를 차례로 부여

![image-20220316214940624](Tree%201.assets/image-20220316214940624.png)

- 노드 번호의 성질
  - 노드 번호가 `i`인 노드의 부모 번호 : `i // 2`
  - 노드 번호가 `i`인 노드의 왼쪽 자식 노드 번호 : `2*i`
  - 노드 번호가 `i`인 노드의 오른쪽 자식 노드 번호 :  `2*i +1`
  - 레벨 n의 노드 번호의 시작 번호 :  2<sup>n</sup>

- 이진 트리는 노드 번호를 배열의 인덱스로 사용한다.

![image-20220316221256841](Tree%201.assets/image-20220316221256841.png)

## 이진 트리 구현

1. `부모 번호를 인덱스로 자식 번호를 저장`

```python
'''
4 (간선의 개수)
1 2 1 3 3 4 3 5
'''

E = int(input())  # edge 수 (간선 수)
arr = list(map(int, input().split()))
V = E + 1        # 정점 수 == 1번 부터 V번까지 정점이 있을 때 마지막 정점

# 부모번호를 인덱스로 자식번호 저장
ch1 = [0] * (V+1)
ch2 = [0] * (V+1)
for i in range(E):
    p, c = arr[i*2], arr[i*2+1]    # 부모 자식 관계
    if ch1[p] == 0:      # 아직 자식이 없는 경우
        ch1[p] = c
    else:
        ch2[p] = c
        
print(ch1)   =>  [0, 2, 0, 4, 0, 0]
print(ch2)   =>	 [0, 3, 0, 5, 0, 0]
```

2. `자식 번호를 인덱스로 부모 번호를 저장`

```python
'''
4 (간선의 개수)
2 1 2 4 4 3 4 5
'''
E = int(input())
arr = list(map(int, input().split()))
V = E + 1

# 자식 번호를 인덱스로 부모 번호 저장
par = [0] * (V+1)
for i in range(E):
    p, c = arr[i*2], arr[i*2+1]
    par[c] = p
    
print(par)   =>  [0, 0, 1, 1, 3, 3]
# 2의 부모 1, 3의 부모 1, 4의 부모 3, 5의 부모 3
```

2-1. `root 찾기`

```python
# root 찾기
root = 0
for i in range(1, V+1):
    if par[i] == 0:    # 부모가 없는 i번 정점이 root
        root = i
        break
print(root)    =>  1
```

2-2. `c의 조상 찾기`

```python
anc = []  # 조상 목록 저장
c = 5  # 조상을 찾을 정점 번호
while par[c] != 0:  # c가 root가 아니면
    anc.append(par[c])
    c = par[c]      # c의 부모(par[c])를 자식으로 
print(*anc)
```

3. `연습 문제`

> 다음 이진 트리 표현에 대하여 전위 순회하여 정점의 번호를 출력해라
>
> - 정점의 개수 : 13
>
> - 1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13

```python
ch1 = [0] * (v+1)
ch2 = [0] * (v+1)
for i in range(v-1):
    p, c = lst[i*2], lst[i*2+1]
    if ch1[p] == 0:
        ch1[p] = c
    else:
        ch2[p] = c
        
def pre_order(start):
    if start:
        print(start, end=' ')
        pre_order(ch1[start])
        pre_order(ch2[start])
pre_order(1)	=> 1 2 4 7 12 3 5 8 9 6 10 11 13 
```



## 이진 탐색 트리

- 루트에서 시작한다.
- 탐색할 키 값 x를 루트 노드의 키 값과 비교한다.
  - x == 루트 노드의 키 값 : 원하는 원소를 찾았으므로 탐색 성공
  - x < 루트 노드의 키 값 : 루트 노드의 왼쪽 서브트리에 대해서 탐색 연산 수행
  - x > 루트 노드의 키 값 : 루트 노드의 오른쪽 서브트리에 대해서 탐색 연산 수행

![image-20220316225235086](Tree%201.assets/image-20220316225235086.png)





## heap

> 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조

- `완전 이진트리에서 기본적인 전위 탐색`

```python
# 완전 이진트리에서의 순회
def pre_order(v):
    global last
    if v <= last    # 마지막 정점 번호 이내이면
        print(v, end = ' ')   # visit(v)
        pre_order(v*2)   # 왼쪽 자식 정점 방문
        pre_order(v*2+1)   # 오른쪽 자식 정점 방문
print(pre_order(1))
```

### 최대 힙(max heap)

- 키 값이 가장 큰 노드를 찾기 위한 `완전 이진 트리`
- 부모 노드의 키 값 > 자식 노드의 키 값
- 루트 노드 : 키 값이 가장 큰 노드

### 최소 힙(min heap)

- 키 값이 가장 작은 노드를 찾기 위한 `완전 이진 트리`
- 부모 노드의 키 값 < 자식 노드의 키 값
- 루트 노드 : 키 값이 가장 작은 노드



### `최대 힙에서 삽입과 연산`

```python
# 힙 연산 -  삽입
# 최대 100개의 자연수가 키로 입력
# 최대 힙

def enq(n):
    global last # 마지막 정점 번호
    last += 1
    tree[last] = n   # 완전 이진트리 유지
    c = last  # 새로 추가된 정점을 자식으로
    p = c//2  # 완전이진트리에서의 부모 정점 번호
    
    while p  >= 1 and tree[p] < tree[c]:   # 부모가 있고, 자식의 키값이 더 크면 교환
        tree[p], tree[c] = tree[c], tree[p]
        c = p
        p = c // 2
 
# 포화이진트리의 정점번호 1~100까지 미리 준비
tree = [0]*(101)
last = 0   # 마지막 정점 번호
enq(3)
enq(2)
enq(4)
enq(7)
enq(5)
enq(1)
print(tree[1])  => 7
```

```python
# 힙 연산 - 삭제
def deq():
    global last
    tmp = tree[1]     # 루트의 key 값
    tree[1] = tree[last]    # 마지막 정점의 키를 루트에 복사
    last -= 1               # 마지막 정점 삭제
    
    # 부모 > 자식 규칙 유지 (최대 힙을 유지 시키려고)
    p = 1
    c = p * 2   # 왼쪽 자식노드 번호
    while c <= last:   # 왼쪽 자식이 있으면,
        if c + 1 <= last and tree[c] < tree[c+1]:     # 오른쪽 자식노드도 있고, 오른쪽 자식이 더 크면,
            c += 1  # 오른쪽 자식 선택
        if tree[p] < tree[c]:    # 자식의 키 값이 더 크면 교환
            tree[p], tree[c] = tree[c], tree[p]
            p = c
            c = p * 2         
        else:
            break
    return tmp

while last > 0:
    print(deq(), tree[1]) # deq할 때마다 루트의 값이 어떻게 바뀌는지 볼려구
    
7 5
5 4
4 3
3 2
2 1
1 1
```





