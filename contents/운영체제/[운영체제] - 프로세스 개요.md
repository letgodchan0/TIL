# [운영체제] - 프로세스 개요

프로세스 관리는 운영체제의 핵심 서비스! 

<hr>

<br>

프로그램은 실행되기 전까지는 그저 보조기억장치에 있는 데이터일 뿐이지만, 보조기억장치에 저장된 프로그램을 메모리에 적재하고 실행하는 순간, 그 프로그램은 프로세스가 된다. 그리고 이 과정을 '프로세스를 생성한다'고 표현한다. 사용자가 보는 곳에서 실행되는 프로세스를 `포그라운드 프로세스`, 사용자가 보지 못하는 곳에서 실행되는 것을 `백그라운드 프로세스`라고 한다.

백그라운드 프로세스 중 사용자와 직접 상호작용하지 않고 그저 묵묵히 정해진 일만 수행하는 백그라운드 프로세스가 있다. 유닉스 체계의 운영체제에서는 `데몬`이라 부르고, 윈도우 운영체제에서는 `서비스`라고 한다.

<br>

### - 프로세스 제어 블록

![image-20221130220907077](%5B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%5D%20-%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EA%B0%9C%EC%9A%94.assets/image-20221130220907077.png)

운영체제는 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고, 프로세스에 CPU를 비롯한 자원을 배분한다. 이를 위해 운영체제는 `프로세스 제어 블록(PCB)`을 이용한다. 프로세스 제어 블록은 프로세스와 관련된 정보를 저장하는 자료 구조이다. 옷에 달려 있는 태그에 해당 제품을 식별하기 위한 정보가 있는 것처럼 프로세스 제어 블록에는 해당 프로세스를 식별하기 위해 꼭 필요한 정보들이 저장된다.

PCB는 커널 영역에 생성된다. 운영체제는 수많은 프로세스들 사이에서 PCB로 특정 프로세스를 식별하고 해당 프로세스를 처리하는 데 필요한 정보를 판단한다. PCB는 프로세스가 생성 시에 만들어지고 실행이 끝나면 폐기된다. 

PCB에 담기는 정보를 알아보자!

<hr>

#### 1. 프로세스 ID

프로세스 ID는 특정 프로세스를 식별하기 위해 부여하는 고유 번호이다. 같은 일을 수행하는 프로그램이라 할지라도 두 번 실행하면 PID가 다른 두 개의 프로세스가 생성된다.

#### 2. 레지스터 값

프로세스는 자신의 실행 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원한다. 그래야 이전까지 진행했던 작업들을 그대로 이어 실행할 수 있다. 그래서 PCB 안에는 해당 프로세스가 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값들이 담긴다.

```text
레지스터 : CPU가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치
프로그램 카운터 : 프로세서 내부에 있는 레지스터 중 하나로, 다음에 실행될 명령어의 주소를 갖고 있음
```

#### 3. 프로세스 상태

현재 프로세스가 어떤 상태인지 PCB에 기록된다. 프로세스가 입출력장치를 사용하기 위해 기다리는 상태인지, CPU를 사용하기 위해 기다리는 상태인지 등의 프로세스 상태 정보가 저장된다.

#### 4. CPU 스케줄링 정보

프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보도 PCB에 기록된다.

#### 5. 메모리 관리 정보

프로세스마다 메모리에 저장된 위치가 다르다. 그래서 PCB에는 프로세스가 어느 주소에 저장되어 있는지에 대한 정보가 있다. 또한 프로세스의 주소를 알기 위한 또 다른 중요 정보 중 하나인 페이지 테이블 정보도 담긴다.

#### 6. 사용한 파일과 입출력장치 목록

프로세스가 실행 과정에서 특정 입출력장치나 파일을 사용하면 PCB에 해당 내용이 명시된다. 즉, 어떤 입출력장치가 이 프로세스에 할당되었는지, 어떤 파일들을 열었는지에 대한 정보들이 PCB에 기록된다.

<BR>

### - 문맥 교환

하나의 프로세스에서 다른 프로세스로 실행 순서가 넘어갈 때, 가령 메모장이 운영체제로부터 CPU를 할당받아 실행되다가 시간이 다 되어 PDF에 CPU 사용을 양보한다고 가정해보자.

이 때 메모장은 프로그램 카운터를 비롯한 각종 레지스터 값, 메모리 정보, 실행을 위해 열었던 파일이나 사용한 입출력장치 등 지금까지의 중간 정보를 백업해야 한다. 그래야 다음 차례가 왔을 때 이전까지 실행한 내용을 이어서 재개할 수 있기 때문이다.

이러한 중간 정보, 즉 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보를 `문맥`이라고 한다. 하나의 프로세스 문맥은 해당 프로세스의 PCB에 표현되어 있다. PCB에 기록되는 정보들을 문맥이라고 봐도 된다. 실행 문맥을 잘 기억해 두면, 언제든 해당 프로세스의 실행을 재개할 수 있기 때문에 프로세스가 CPU를 사용할 수 있는 시간이 다 되거나 예기치 못한 상황이 발생하여 인터럽트가 발생하면, 운영체제는 해당 프로세스의 PCB에 문맥을 백업한다. 그리고 뒤이어 실행할 프로세스 B의 문맥을 복구한다. 이렇게 자연스럽게 실행되는 프로세스가 바뀐다!

![image-20221130222607826](%5B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%5D%20-%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EA%B0%9C%EC%9A%94.assets/image-20221130222607826.png)

이처럼 기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것을 `문맥 교환`이라고 한다.

<BR>

### - 프로세스의 메모리 영역

하나의 프로세스는 사용자 영역에 크게 `코드 영역`, `데이터 영역`, `힙 영역`, `스택 영역`으로 나뉘어 저장된다. 

#### 1. 코드 영역

텍트스 영역이라고도 부르며, 말 그대로 실행할 수 있는 코드, 즉, 기계어로 이루어진 명령어가 저장된다. 코드 영역에는 데이터가 아닌 CPU가 실행할 명령어가 담겨 있기 때문에 쓰기가 금지 되며, 읽기 전용 공간이다.

#### 2. 데이터 영역

프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간,  `전역 변수`가 대표적인 데이터이다. 프로그램이 실행되는 동안 유지되며, 프로그램 전체에 접근할 수 있는 변수이다. 

```TEXT
- 코드 영역과 데이터 영역은 크기가 변하지 않아서 "정적 할당 영역"이라 부른다.
- 힙 영역과 스택 영역은 프로세스 실행 과정에서 크기가 변할 수 있어 "동적 할당 영역"이라 부른다.
```

#### 3. 힙 영역

프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장 공간이다. 사용자는 언젠가 이 공간을 반환해야 한다. 메모리 공간을 반환한다는 것은 ''더이상 해당 메모리 공간을 사용하지 않겠어''라고 운영체제에 말해주는 것과 같다. 반환하지 않으면 메모리 방비를 초래하고 이를 `메모리 누수`라고 한다.

#### 4. 스택 영역

데이터를 일시적으로 저장하는 공간이다. 잠깐 쓰다가 말 값들이 저장되는 공간으로 매개 변수, 지역 변수가 대표적이다. 