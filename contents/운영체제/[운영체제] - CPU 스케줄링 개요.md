# [운영체제] - CPU 스케줄링 개요

모든 프로세스가 공통으로 사용하는 자원이 있다면 그건 CPU, 따라서 운영체제가 프로세스에게 분배하는 자원 중 가장 중요한 자원은 CPU이다. 운영체제가 프로세스에 CPU를 나눠주는 방법인 스케줄링에 대해 알아보자!

<hr>

<br>

```text
CPU 스케줄링 : 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것
```

### - 프로세스 우선순위

우선순위가 높은 프로세스에는 대표적으로 입출력 작업이 많은 프로세스가 있다. 대부분의 프로세스는 CPU와 입출력장치를 모두 사용하며 실행된다. 즉, 프로세스는 실행 상태와 대기 상태를 반복하며 실행된다.

예를 들어, 메모장 프로세스는 CPU를 사용하여 명령어를 실행하고, 입력받은 내용을 보조기억장치에 저장하고, CPU를 사용하여 명령어를 실행하고, 입력한 내용을 화면에 출력하는 과정을 반복하며 실행된다.

| CPU 사용      | 입출력장치 사용               | CPU 사용 | 입출력장치 사용 | CPU 사용 | 입출력장치 사용 | ...  |
| ------------- | ----------------------------- | -------- | --------------- | -------- | --------------- | ---- |
| CPU 사용 구간 | 입출력 완료까지 대기하는 시간 | ...      | ...             | ...      | ...             | ...  |

프로세스 종류마다 입출력장치 이용 시간과, CPU 이용 시간의 차이가 있다.

```TEXT
- 입출력 집중 프로세스 : 비디오 재생이나 디스크 백업 작업을 담당하는 등 입출력 작업이 많은 프로세스
- CPU 집중 프로세스 : 복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 등, CPU 작업이 많은 프로세스
```

`입출력 집중 프로세스`는 실행 상태보다는 입출력을 위한 대기 상태에 더 많이 머무르는 반면, `CPU 집중 프로세스`는 대기 상태보다는 실행 상태에 더 많이 머무른다.

따라서 입출력 집중 프로세스를 가능한 빨리 실행시켜 입출력장치를 끊임없이 작동시키고, 그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 효율적이다. 입출력장치가 입출력 작업을 완료하기 전까지는 입출력 집중 프로세스는 어차피 대기 상태가 될 예정이기 때문에, 입출력 집중 프로세스를 얼른 먼저 처리해 버리면 다른 프로세스가 CPU를 사용할 수 있다.

이렇게 운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다. 우선순위가 높은 프로세스는 더 빨리, 더 자주 실행된다.

<BR>

### - 스케줄링 큐

PCB에 우선순위가 적혀 있다고는 하지만, CPU를 원하는 프로세스들이 한 두개도 아니고, CPU를 요구하는 새로운 프로세스는 언제든 생길 수 있기 때문에, 운영체제가 모든 PCB의 우선순위를 확인하는 것은 비효율적인 일이다. CPU 뿐만 아니라 다른 자원(메모리, 입출력장치, 보조기억장치 등)을 이용할 프로세스를 결정하는 것도 매한가지다.

![image-20221204223420278](%5B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%5D%20-%20CPU%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%20%EA%B0%9C%EC%9A%94.assets/image-20221204223420278.png)

그래서 운영체제는 CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 프로세스들을 모두 줄 세우고, 운영체제는 이 줄을 `스케줄링 큐`로 구현하고 관리한다.

`준비 큐` : CPU를 이용하고 싶은 프로세스들이 서는 줄

`대기 큐` : 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄

![image-20221204224032192](%5B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%5D%20-%20CPU%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%20%EA%B0%9C%EC%9A%94.assets/image-20221204224032192.png)

1. 준비 상태에 있는 프로세스들의 PCB는 준비 큐의 마지막에 삽입되어 CPU를 사용할 차례를 기다린다.
2. 운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 그 중 우선순위가 높은 프로세스를 먼저 실행한다.

```TEXT
우선순위가 낮은 프로세스가 먼저 큐에 삽입 되어도 우선순위가 높은 프로세스가 먼저 처리될 수 있음
```

![image-20221204224319661](%5B%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%5D%20-%20CPU%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%20%EA%B0%9C%EC%9A%94.assets/image-20221204224319661.png)

1. 같은 장치를 요구한 프로세스는 같은 대기 큐에서 기다린다.

2. 입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, 이 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거한다.
3. 해당 PCB는 준비 큐로 이동한다.

<BR>

### - 선점형과 비선점형 스케줄링

`선점형 스케줄링` : 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식

프로세스마다 정해진 시간만큼 자원을 사용하고, 정해진 시간을 소비하여 타이머 인터럽트가 발생하면 운영체제가 해당 프로세스로부터 자원을 빼앗아 다음 프로세스로 할당하는 방식

```TEXT
장점 : 어느 한 프로세스의 자원 독점을 막고 프로세스에 골고루 자원을 배분할 수 있음
단점 : 문맥 교환 과정에서 오버헤드가 발생할 수 있음
```

<BR>

`비선점형 스케줄링` : 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들 수 없는 스케줄링 방식

하나의 프로세스가 자원을 독점할 수 있기 때문에 비선점형 스케줄링 방식으로 자원을 이용하는 프로세스가 있다면, 다른 프로세스들은 그 프로세스의 사용이 모두 끝날 때까지 기다려야 한다.

```TEXT
장점 : 문맥 교환의 횟수가 선점형 스케줄링보다 적기 때문에 오버헤드가 적음
단점 : 모든 프로세스가 골고루 자원을 사용할 수 없음, 자원 사용 끝나기까지 무작정 기다려야 함
```

