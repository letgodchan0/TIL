# Spring Data JPA - ORM

[인프런 백기선님 참고](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-jpa/dashboard)

<hr>

<br>

자바 진영에서 JDBC를 사용하기에 실행하는 비용이 비싸거나, 스키마 변경으로 인해 코드가 너무 많이 바뀌는 등, 불편한 점이 너무 많았다. 따라서 JDBC 대신 도메인 모델을 사용하려는데, 그 이유는 다음과 같다.

```java
// JDBC에 비해 도메인 모델기반으로 작성하면 벌써 코드가 간편함
Member member = new Member("lee");
memberRepository.save(member);
```

- 객체 지향 프로그래밍의 장점을 활용하기 좋음!!
- 비즈니스 로직 구현 및 테스트가 편함
- 코드 재사용
- 각종 디자인 패턴

<br>

#### - ORM 

애플리케이션의 클래스와 `SQL` DB의 테이블 사이의 맵핑 정보를 기술한 메타데이터를 사용하여, 자바 애플리케이션의 객체를 `SQL` DB의 테이블에 자동으로 (또 깨끗하게) 영속화 해주는 기술

`맵핑 정보를 기술한 메타데이터` : 맵핑 정보는 어떤 도메인 모델에 있는 클래스가 어떤 테이블과 매핑 되는지에 대한 정보

`성능 최적화` : 여러가지 방법이 있지만, 기본적으로 `Hibernate`는 객체와 테이블의 데이터 사이에 캐시를 둔다. 따라서 어떤 트랜잭션 안에서 불필요한 쿼리를 날리지 않는다.

- 한 트랜잭션 안에서 사용자 이름을 계속 변경하고 저장한다면, 쿼리는 변경할 때마다 쿼리를 날리지만, ORM을 사용하면 객체가 변경됨을 감지하고, 반영해야 됨을 결정하고, 정말 DB에 반영해야하는 시점에만 변경사항을 반영한다. 즉, 마지막에 변경한 값에 대해서만 쿼리를 날린다.
- 하나의 트랜잭션 내에서 여러 요청이 일어나도 정말로 데이터베이스에 반영해야되는 시점에만 반영을함

<br>

#### - 패러다임 불일치

객체를 릴레이션에 매핑할 때 발생하는 문제와 해결책

<br>

**밀도(Granularity) 문제**

| 객체                                                         | 릴레이션                             |
| ------------------------------------------------------------ | ------------------------------------ |
| 다양한 크기의 객체를 만들 수 있음. 커스텀한 타입 만들기 쉬움. | 테이블 기본 데이터 타입 (UDT는 비추) |

 <br>

**서브타입(Subtype) 문제** 

| 객체                           | 릴레이션                                                     |
| ------------------------------ | ------------------------------------------------------------ |
| 상속 구조 만들기 쉬움. 다형성. | 테이블 상속이라는게 없음. 상속 기능을 구현했다 하더라도 표준 기술이 아님. 다형적인 관계를 표현할 방법이 없음. |

 <br>

**식별성(Identity) 문제**

| 객체                                                   | 릴레이션           |
| ------------------------------------------------------ | ------------------ |
| 레퍼런스 동일성 (==) 인스턴스 동일성 (equals() 메소드) | 주키 (primary key) |

 <br>

**관계(Association) 문제**

| 객체                                                         | 릴레이션                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 객체 레퍼런스로 관계 표현. 근본적으로 ‘방향'이 존재 한다. 다대다 관계를 가질 수 있음 | 외래키(foreign key)로 관계 표현. ‘방향'이라는 의미가 없음. 그냥 Join으로 아무거나 묶을 수 있음. 태생적으로 다대다 관계를 못만들고, 조인 테이블 또는 링크 테이블을 사용해서 두개의 1대다 관계로 풀어야 함. |

 <br>

**데이터 네비게이션(Navigation)의 문제** 

| 객체                                                         | 릴레이션                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 레퍼런스를 이용해서 다른 객체로 이동 가능. 콜렉션을 순회할 수도 있음. | 하지만 그런 방식은 릴레이션에서 데이터를 조회하는데 있어서 매우 비효율적이다. 데이터베이스에 요청을 적게 할 수록 성능이 좋다. 따라서 Join을 쓴다. 하지만, 너무 많이 한번에 가져오려고 해도 문제다. 그렇다고 lazy loading을 하자니 그것도 문제다. (n+1 select) |

<br>